@echo off
setlocal

rem Select PowerShell (prefer pwsh, fallback to Windows PowerShell)
where pwsh >NUL 2>&1
if %ERRORLEVEL% EQU 0 (
    set "PS_EXE=pwsh"
) else (
    where powershell >NUL 2>&1
    if %ERRORLEVEL% EQU 0 (
        set "PS_EXE=powershell"
    ) else (
        echo PowerShell is not installed. Install PowerShell 7 or Windows PowerShell and retry.
        exit /b 1
    )
)

rem Resolve repository root (this file's directory)
set "REPO_PATH=%~dp0"
for %%I in ("%REPO_PATH:~0,-1%") do set "REPO_PATH=%%~fI"

rem Temp PowerShell script we generate for clarity/easy edits
set "TMP_PS=%TEMP%\install_path_%RANDOM%.ps1"

rem --- PowerShell script content (easy to edit/add lines) ---
>"%TMP_PS%" echo # Generated by install.bat - updates user PATH for Matrix and Pomodoro
>>"%TMP_PS%" echo $ErrorActionPreference = 'Stop'
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Locate project folders
>>"%TMP_PS%" echo $repoPath    = Convert-Path '%REPO_PATH%'
>>"%TMP_PS%" echo $matrixDir   = Join-Path $repoPath 'Matrix'
>>"%TMP_PS%" echo $pomodoroDir = Join-Path $repoPath 'Pomodoro - Matrix'
>>"%TMP_PS%" echo $required    = @($matrixDir, $pomodoroDir)
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Ensure folders exist before touching PATH
>>"%TMP_PS%" echo foreach ($d in $required) {
>>"%TMP_PS%" echo ^    if (-not (Test-Path $d)) { throw "Required directory not found: $d" }
>>"%TMP_PS%" echo }
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Load current user PATH as an ordered list
>>"%TMP_PS%" echo $currentPath = [Environment]::GetEnvironmentVariable('Path','User')
>>"%TMP_PS%" echo $segments    = @()
>>"%TMP_PS%" echo if ($currentPath) {
>>"%TMP_PS%" echo ^    $segments = $currentPath -split ';' ^| Where-Object { $_ -ne '' } ^| ForEach-Object { $_.Trim() }
>>"%TMP_PS%" echo }
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Keep uniqueness case-insensitively
>>"%TMP_PS%" echo $set = [System.Collections.Generic.HashSet[string]]::new([System.StringComparer]::OrdinalIgnoreCase)
>>"%TMP_PS%" echo foreach ($s in $segments) { [void]$set.Add($s) }
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Add missing entries
>>"%TMP_PS%" echo $added = @()
>>"%TMP_PS%" echo foreach ($d in $required) {
>>"%TMP_PS%" echo ^    if ($set.Add($d)) { $segments += $d; $added += $d }
>>"%TMP_PS%" echo }
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Persist PATH (user scope)
>>"%TMP_PS%" echo $newPath = ($segments ^| Where-Object { $_ }) -join ';'
>>"%TMP_PS%" echo [Environment]::SetEnvironmentVariable('Path',$newPath,'User')
>>"%TMP_PS%" echo.
>>"%TMP_PS%" echo # Report result
>>"%TMP_PS%" echo if ($added.Count -gt 0) {
>>"%TMP_PS%" echo ^    Write-Host 'User PATH updated:'
>>"%TMP_PS%" echo ^    $added ^| ForEach-Object { Write-Host '  + ' $_ }
>>"%TMP_PS%" echo } else {
>>"%TMP_PS%" echo ^    Write-Host 'User PATH already contained required entries.'
>>"%TMP_PS%" echo }
>>"%TMP_PS%" echo Write-Host 'Restart PowerShell to pick up PATH changes.'
rem --- End PowerShell script content ---

"%PS_EXE%" -NoLogo -NoProfile -ExecutionPolicy Bypass -File "%TMP_PS%"
set "RC=%ERRORLEVEL%"
if exist "%TMP_PS%" del "%TMP_PS%" >NUL 2>&1

endlocal
exit /b %RC%